## Java后端工程师面试必备    

本分享资源由 [[yew1eb](https://github.com/yew1eb)] 整理自网络, 如有侵权请联系我立即修改!

**************

### 一、Java面向对象
1. 类和对象
2. 封装
3. 继承
4. 多态

* 笔记：[1. java-OOP.md](/1.java-OOP.md)

**************

### 二、Java常见工具类
#### 1. 异常与异常处理  
* 笔记：[2.1 Java Exception.md](/2.1 Java Exception.md)

#### 2. String类
1. String类为什么是final的。  
<https://www.zhihu.com/question/31345592>   
2. string、stringbuilder、stringbuffer区别  
String 类型和 StringBuffer 类型的主要性能区别其实在于 String 是不可变的对象  
StringBuffer和StringBuilder底层都是 char[]数组实现的  
StringBuffer是线程安全的，而StringBuilder是线程不安全的，但性能略高。

#### 3. 基本类型的装箱和拆箱
* 装箱：把基本类型转换成包装类，使其具有对象的性质，又可分为手动装箱和自动装箱  
* 拆箱：和装箱相反，把包装类对象转换成基本类型的值，又可分为手动拆箱和自动拆箱
Java 中基本类型和字符串之间的转换
* 基本数据类型和字符串之间进行转换  

		基本类型转换为字符串有三种方法：  
			1. 使用包装类的 toString() 方法
			2. 使用String类的 valueOf() 方法
			3. 用一个空字符串加上基本类型，得到的就是基本类型数据对应的字符串    
		字符串转换成基本类型有两种方法：  
			1. 调用包装类的 parseXxx 静态方法  
			2. 调用包装类的 valueOf() 方法转换为基本类型的包装类，会自动拆箱

#### 4. 时间相关的类
	java.text.SimpleDateFormat;  
	SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
	调用format()方法，将日期转换为字符串并输出
	调用parse()方法，将字符串转换为日期Date
	java.util.Date;
	Date 类的默认无参构造方法创建出的对象就代表当前时间

**************

### 三、 Java 中的集合框架
2. HashMap的源码，实现原理，底层结构。

3. 说说你知道的几个Java集合类：list、set、queue、map实现类。
ArrayList、LinkedList、Vector的区别：ArrayList 和Vector底层是采用数组方式存储数据，Vector由于使用了synchronized方法（线程安全）所以性能上比ArrayList要差，LinkedList使用双向链表实现存储，随机存取比较慢
HashMap的底层源码实现：当我们往HashMap中put元素的时候，先根据key的hashCode重新计算hash值，根据hash值得到这个元素在数组中的位置（即下标），如果数组该位置上已经存放有其他元素了，那么在这个位置上的元素将以链表的形式存放，新加入的放在链头，最先加入的放在链尾。如果数组该位置上没有元素，就直接将该元素放到此数组中的该位置上。
Fail-Fast机制:在使用迭代器的过程中有其他线程修改了map，那么将抛出ConcurrentModificationException，这就是所谓fail-fast机制。这一机制在源码中的实现是通过modCount域，modCount顾名思义就是修改次数，对HashMap内容的修改都将增加这个值，那么在迭代器初始化过程中会将这个值赋给迭代器的expectedModCount。在迭代过程中，判断modCount跟expectedModCount是否相等，如果不相等就表示已经有其他线程修改了Map.

4. 描述一下ArrayList和LinkedList各自实现和区别Vector
ArrayList 与 Vector 底层都是使用了Object数组实现的，ArrayList是1.0出现的，是线程不安全的，效率高
	Vector是JDK 1.5 出现的，是线程不安全的，效率低   
	
	ArrayList 底层是使用了Object数组实现的， 查询快  增删慢
	LinkeList  底层是使用了链表数据实现的，  查询慢 增删快
		
	如果我们需要保留存储顺序的，并且保留重复元素的时候，使用List.
	如果查询比较多，那么使用ArraysList 如果存取比较多，那么使用LiskedList
	如果需要线程安全的，那么使用Vector

5. Java中的队列都有哪些，有什么区别。

8. Java数组和链表两种结构的操作效率，在哪些情况下(从开头开始，从结尾开始，从中间开始)，哪些操作(插入，查找，删除)的效率高。
		
		
11. hashtable和hashmap的区别
HashTable比较老，是基于Dictionary 类实现的，HashTable 则是基于 Map接口实现的
HashTable 是线程安全的， HashMap 则是线程不安全的
HashMap可以让你将空值作为一个表的条目的key或value

**************

6. 反射的作用于原理 反射中，Class.forName和classloader的区别。java多态的实现原理
抽象的来讲，多态的意思就是同一消息可以根据发送对象的不同而采用多种不同的行为方式。（发送消息就是函数调用）
实现的原理是动态绑定，程序调用的方法在运行期才动态绑定，追溯源码可以发现，JVM 通过参数的自动转型来找到合适的办法。


7. Java7、Java8的新特性




9. Java内存泄露的问题调查定位：jmap，jstack的使用等等。



16. Java的四种引用，强弱软虚，用到的场景
强引用：如果一个对象具有强引用，它就不会被垃圾回收器回收。即使当前内存空间不足，JVM 也不会回收它，而是抛出 OutOfMemoryError 错误，使程序异常终止。如果想中断强引用和某个对象之间的关联，可以显式地将引用赋值为null，这样一来的话，JVM在合适的时间就会回收该对象
软引用：在使用软引用时，如果内存的空间足够，软引用就能继续被使用，而不会被垃圾回收器回收，只有在内存不足时，软引用才会被垃圾回收器回收。
弱引用：具有弱引用的对象拥有的生命周期更短暂。因为当 JVM 进行垃圾回收，一旦发现弱引用对象，无论当前内存空间是否充足，都会将弱引用回收。不过由于垃圾回收器是一个优先级较低的线程，所以并不一定能迅速发现弱引用对象
虚引用：顾名思义，就是形同虚设，如果一个对象仅持有虚引用，那么它相当于没有引用，在任何时候都可能被垃圾回收器回收。
使用场景：
利用软引用和弱引用解决OOM问题：用一个HashMap来保存图片的路径和相应图片对象关联的软引用之间的映射关系，在内存不足时，JVM会自动回收这些缓存图片对象所占用的空间，从而有效地避免了OOM的问题
通过软可及对象重获方法实现Java对象的高速缓存:比如我们创建了一Employee的类，如果每次需要查询一个雇员的信息。哪怕是几秒中之前刚刚查询过的，都要重新构建一个实例，这是需要消耗很多时间的。我们可以通过软引用和 HashMap 的结合，先是保存引用方面：以软引用的方式对一个Employee对象的实例进行引用并保存该引用到HashMap 上，key 为此雇员的 id，value为这个对象的软引用，另一方面是取出引用，缓存中是否有该Employee实例的软引用，如果有，从软引用中取得。如果没有软引用，或者从软引用中得到的实例是null，重新构建一个实例，并保存对这个新建实例的软引用


17. 抽象类和接口的区别
一个类只能继承单个类，但是可以实现多个接口
接口强调特定功能的实现，而抽象类强调所属关系
抽象类中的所有方法并不一定要是抽象的，你可以选择在抽象类中实现一些基本的方法。而接口要求所有的方法都必须是抽象的
解析XML的几种方式的原理与特点：DOM、SAX、PULL
DOM：消耗内存：先把xml文档都读到内存中，然后再用DOM API来访问树形结构，并获取数据。这个写起来很简单，但是很消耗内存。要是数据过大，手机不够牛逼，可能手机直接死机
SAX：解析效率高，占用内存少，基于事件驱动的：更加简单地说就是对文档进行顺序扫描，当扫描到文档(document)开始与结束、元素(element)开始与结束、文档(document)结束等地方时通知事件处理函数，由事件处理函数做相应动作，然后继续同样的扫描，直至文档结束。
SAX：与 SAX 类似，也是基于事件驱动，我们可以调用它的next（）方法，来获取下一个解析事件（就是开始文档，结束文档，开始标签，结束标签），当处于某个元素时可以调用XmlPullParser的getAttributte()方法来获取属性的值，也可调用它的nextText()获取本节点的值。
wait()和sleep()的区别
sleep来自Thread类，和wait来自Object类
调用sleep()方法的过程中，线程不会释放对象锁。而 调用 wait 方法线程会释放对象锁
sleep睡眠后不出让系统资源，wait让出系统资源其他线程可以占用CPU
sleep(milliseconds)需要指定一个睡眠时间，时间一到会自动唤醒
JAVA 中堆和栈的区别，说下java 的内存机制




19. Hashtable,HashMap,ConcurrentHashMap底层实现原理与线程安全问题。


20. 如果不让你用Java Jdk提供的工具，你自己实现一个Map，你怎么做。说了好久，说了HashMap源代码，如果我做，就会借鉴HashMap的原理，说了一通HashMap实现。


21. Hash冲突怎么办？哪些解决散列冲突的方法？


22. HashMap冲突很厉害，最差性能，你会怎么解决?从O（n）提升到log（n）。


23. rehash


24. hashCode() 与 equals() 生成算法、方法怎么重写。
同样用于鉴定2个对象是否相等的，java集合中有 list 和 set 两类，其中 set不允许元素重复实现，那个这个不允许重复实现的方法，如果用 equal 去比较的话，如果存在1000个元素，你 new 一个新的元素出来，需要去调用1000次 equal 去逐个和他们比较是否是同一个对象，这样会大大降低效率。hashcode实际上是返回对象的存储地址，如果这个位置上没有元素，就把元素直接存储在上面，如果这个位置上已经存在元素，这个时候才去调用equal方法与新元素进行比较，相同的话就不存了，散列到其他地址上

25. 泛型常用特点，List<String>能否转为List<Object>

26. Object有哪些公用方法？
方法equals测试的是两个对象是否相等
方法clone进行对象拷贝
方法getClass返回和当前对象相关的Class对象
方法notify,notifyall,wait都是用来对给定对象进行线程同步的
    
27. Override和Overload的含义去区别
Overload顾名思义是重新加载，它可以表现类的多态性，可以是函数里面可以有相同的函数名但是参数名、返回值、类型不能相同；或者说可以改变参数、类型、返回值但是函数名字依然不变。
就是ride(重写)的意思，在子类继承父类的时候子类中可以定义某方法与其父类有相同的名称和参数，当子类在调用这一函数时自动调用子类的方法，而父类相当于被覆盖（重写）了。
    
28. 基本数据类型比变量和对象的引用都是在栈分配的
堆内存用来存放由new创建的对象和数组
类变量（static修饰的变量），程序在一加载的时候就在堆中为类变量分配内存，堆中的内存地址存放在栈中
实例变量：当你使用java关键字new的时候，系统在堆中开辟并不一定是连续的空间分配给变量，是根据零散的堆内存地址，通过哈希算法换算为一长串数字以表征这个变量在堆中的"物理位置”,实例变量的生命周期--当实例变量的引用丢失后，将被GC（垃圾回收器）列入可回收“名单”中，但并不是马上就释放堆中内存
局部变量: 由声明在某方法，或某代码段里（比如for循环），执行到它的时候在栈中开辟内存，当局部变量一但脱离作用域，内存立即释放
    
    
********

### 二、Java IO

1. 讲讲IO里面的常见类，字节流、字符流、接口、实现类、方法阻塞。


2. 讲讲NIO


3. String 编码UTF-8 和GBK的区别？


4. 什么时候使用字节流、什么时候使用字符流？


5. 递归读取文件夹下的文件，代码怎么实现？


**********

### 三、Java Web


1. session和cookie的区别和联系，session的生命周期，多个服务部署时session管理。


2. servlet的一些相关问题


3. webservice相关问题


4. jdbc连接，forname方式的步骤，怎么声明使用一个事务。


5. 无框架下配置web.xml的主要配置内容


6. jsp和servlet的区别


**********

### 四、JVM


1. Java的内存模型以及GC算法


2. jvm性能调优都做了什么


3. 介绍JVM中7个区域，然后把每个区域可能造成内存的溢出的情况说明。


4. 介绍GC 和GC Root不正常引用


5. 自己从classload 加载方式，加载机制说开去，从程序运行时数据区，讲到内存分配，讲到String常量池，讲到JVM垃圾回收机制，算法，hotspot。


6. jvm 如何分配直接内存， new 对象如何不分配在堆而是栈上，常量池解析。


7. 数组多大放在JVM老年代


8. 老年代中数组的访问方式


9. GC 算法，永久代对象如何 GC ， GC 有环怎么处理。


10. 谁会被 GC ，什么时候 GC。


11. 如果想不被 GC 怎么办


12. 如果想在 GC 中生存 1 次怎么办

13. JAVA 垃圾回收机制
什么是垃圾回收机：释放那些不再持有引用的对象的内存
怎么判断一个对象是否需要收集？
引用计数（最简单古老的方法）：指将资源（可以是对象、内存或磁盘空间等等）的被引用次数保存起来，当被引用次数变为零时就将其释放的过程
对象引用遍历（现在大多数 jvm 使用的方法）：对象引用遍历从一组对象开始，沿着整个对象图上的每条链接，递归确定可到达（reachable）的对象。如果某对象不能从这些根对象的一个（至少一个）到达，则将它作为垃圾收集
    
14. 几种垃圾回收机制 

标记回收法：遍历对象图并且记录可到达的对象，以便删除不可到达的对象，一般使用单线程工作并且可能产生内存碎片

标记-压缩回收法：前期与第一种方法相同，只是多了一步，将所有的存活对象压缩到内存的一端，这样内存碎片就可以合成一大块可再利用的内存区域，提高了内存利用率

复制回收法：把现有内存空间分成两部分，gc运行时，它把可到达对象复制到另一半空间，再清空正在使用的空间的全部对象。这种方法适用于短生存期的对象，持续复制长生存期的对象则导致效率降低。 

分代回收发：把内存空间分为两个或者多个域，如年轻代和老年代，年轻代的特点是对象会很快被回收，因此在年轻代使用效率比较高的算法。当一个对象经过几次回收后依然存活，对象就会被放入称为老年的内存空间，老年代则采取标记-压缩算法
    
**********

### 五、开源框架


1. hibernate和ibatis的区别


2. 讲讲mybatis的连接池


3. spring框架中需要引用哪些jar包，以及这些jar包的用途


4. springMVC的原理


5. springMVC注解的意思


6. spring中beanFactory和ApplicationContext的联系和区别   
在Spring Ioc容器的代表就是org.springframework.beans包中的BeanFactory接口，BeanFactory接口提供了IoC容器最基本功能；而org.springframework.context包下的ApplicationContext接口扩展了BeanFactory，还提供了与Spring AOP集成、国际化处理、事件传播及提供不同层次的context实现 (如针对web应用的WebApplicationContext)。简单说， BeanFactory提供了IoC容器最基本功能，而 ApplicationContext 则增加了更多支持企业级功能支持。ApplicationContext完全继承BeanFactory，因而BeanFactory所具有的语义也适用于ApplicationContext。

7. spring注入的几种方式    
Spring IoC容器注入依赖资源主要有以下两种基本实现方式：  
     构造器注入：就是容器实例化Bean时注入那些依赖，通过在在Bean定义中指定构造器参数进行注入依赖，包括实例工厂方法参数注入依赖，但静态工厂方法参数不允许注入依赖；  
     setter注入：通过setter方法进行注入依赖；  
     方法注入：能通过配置方式替换掉Bean方法，也就是通过配置改变Bean方法 功能。

8. spring如何实现事物管理的


9. springIOC  
<http://jinnianshilongnian.iteye.com/blog/1413846>

10. spring AOP的原理

**********

### 六、多线程

1. Java创建线程之后，直接调用start()方法和run()的区别

2. 常用的线程池模式以及不同线程池的使用场景

3. newFixedThreadPool此种线程池如果线程数达到最大值后会怎么办，底层原理。

4. 多线程之间通信的同步问题，synchronized锁的是对象，衍伸出和synchronized相关很多的具体问题，例如同一个类不同方法都有synchronized锁，一个对象是否可以同时访问。或者一个类的static构造方法加上synchronized之后的锁的影响。

5. 了解可重入锁的含义，以及ReentrantLock 和synchronized的区别

6. 同步的数据结构，例如concurrentHashMap的源码理解以及内部实现原理，为什么他是同步的且效率高。

7. atomicinteger和Volatile等线程安全操作的关键字的理解和使用

8. 线程间通信，wait和notify

9. 定时线程的使用

10. 场景：在一个主线程中，要求有大量(很多很多)子线程执行完之后，主线程才执行完成。多种方式，考虑效率。

11. 进程和线程的区别

12. 什么叫线程安全？

13. 线程的几种状态

14. 并发、同步的接口或方法

15. HashMap 是否线程安全，为何不安全。 ConcurrentHashMap，线程安全，为何安全。底层实现是怎么样的。

16. J.U.C下的常见类的使用。 ThreadPool的深入考察； BlockingQueue的使用。（take，poll的区别，put，offer的区别）；原子类的实现。

17. 简单介绍下多线程的情况，从建立一个线程开始。然后怎么控制同步过程，多线程常用的方法和结构


18. volatile的理解

19. 实现多线程有几种方式，多线程同步怎么做，说说几个线程里常用的方法。  
两大方法：继承 与 实现 
 	继承Thread 方法
		自定义一个类继调用start承Thread,重写Thread的run 方法把自定义线程的任务
代码放在run方法上。创建Thread类的子类对象，并且调用Start方法开启线程
	实现 Runnable 接口
自定义一个类实现Runnable接口，实现Runnable的run方法。把自定义线程的任务代码放在run方法上。创建Runnable实现类的对象。创建Thread的对象，然后把Runnable实现类的对象昨晚参数传递。调用Thread对象的sta线程rt方法开启

synchronized,wait 与notify 都可以实现同步

20.  ThreadLocal的设计理念与作用

**********

### 七、网络通信

1. http是无状态通信，http的请求方式有哪些，可以自己定义新的请求方式么。

2. socket通信，以及长连接，分包，连接异常断开的处理。

3. socket通信模型的使用，AIO和NIO。

4. socket框架netty的使用，以及NIO的实现原理，为什么是异步非阻塞。

5. 同步和异步，阻塞和非阻塞。

6. OSI七层模型，包括TCP,IP的一些基本知识

7. http中，get post的区别

8. 说说http,tcp,udp之间关系和区别。

9. 说说浏览器访问www.taobao.com，经历了怎样的过程。

10. HTTP协议、  HTTPS协议，SSL协议及完整交互过程；

11. tcp的拥塞，快回传，ip的报文丢弃

12. https处理的一个过程，对称加密和非对称加密

13. head各个特点和区别

14. 说说浏览器访问www.taobao.com，经历了怎样的过程。


**********

### 八、数据库MySql

1. MySql的存储引擎的不同

2. 单个索引、联合索引、主键索引

3. Mysql怎么分表，以及分表后如果想按条件分页查询怎么办

4. 分表之后想让一个id多个表是自增的，效率实现

5. MySql的主从实时备份同步的配置，以及原理(从库读主库的binlog)，读写分离。

6. 写SQL语句和SQL优化

7. 索引的数据结构，B+树

8. 事务的四个特性，以及各自的特点（原子、隔离）等等，项目怎么解决这些问题。

9. 数据库的锁：行锁，表锁；乐观锁，悲观锁

10. 数据库事务的几种粒度

11. 关系型和非关系型数据库区别


**********

### 九、设计模式


1. 单例模式：饱汉、饿汉。以及饿汉中的延迟加载，双重检查。


2. 工厂模式、装饰者模式、观察者模式。


3. 工厂方法模式的优点（低耦合、高内聚，开放封闭原则）

4. 生产者消费者模式

**********

### 十一、并发与性能调优


1. 有个每秒钟5k个请求，查询手机号所属地的笔试题，如何设计算法?请求再多，比如5w，如何设计整个系统?


2. 高并发情况下，我们系统是如何支撑大量的请求的


3. 集群如何同步会话状态


4. 负载均衡的原理


5. 如果有一个特别大的访问量，到数据库上，怎么做优化（DB设计，DBIO，SQL优化，Java优化）


6. 如果出现大面积并发，在不增加服务器的基础上，如何解决服务器响应不及时问题“。


7. 假如你的项目出现性能瓶颈了，你觉得可能会是哪些方面，怎么解决问题。


8. 如何查找 造成 性能瓶颈出现的位置，是哪个位置照成性能瓶颈。


9. 你的项目中使用过缓存机制吗？有没用用户非本地缓存

*********

### 十二、其他

1. 常用的linux下的命令

2. Java与C++对比 

*********

### 十三、推荐书籍   
	《java核心技术卷I》  
	《Thinking in java》 
	《java并发编程》
	《effictive java》
	《大话设计模式》